<!doctype html><html lang=en><head><title>An approach to solving the dining philosophers problem ::
riceset</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="üëÄ Overview The Dining Philosophers Problem is a computer science problem formulated in 1965 by Edsger Dijkstra. It involves dealing with concurrent programming, synchronization issues, threads, deadlocks, and race conditions.
The Problem There are one or more philosophers sitting around a table, with a large bowl of spaghetti placed in the middle. In order for a philosopher to eat, they need to use both their left and right forks simultaneously."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://riceset.com/articles/philosophers/><link rel=stylesheet href=https://riceset.com/assets/style.css><link rel=stylesheet href=https://riceset.com/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://riceset.com/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://riceset.com/img/favicon.png><link href=https://riceset.com/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://riceset.com/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://riceset.com/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://riceset.com/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://riceset.com/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://riceset.com/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="An approach to solving the dining philosophers problem"><meta name=twitter:description content="üëÄ Overview The Dining Philosophers Problem is a computer science problem formulated in 1965 by Edsger Dijkstra. It involves dealing with concurrent programming, synchronization issues, threads, deadlocks, and race conditions.
The Problem There are one or more philosophers sitting around a table, with a large bowl of spaghetti placed in the middle. In order for a philosopher to eat, they need to use both their left and right forks simultaneously."><meta property="og:title" content="An approach to solving the dining philosophers problem"><meta property="og:description" content="üëÄ Overview The Dining Philosophers Problem is a computer science problem formulated in 1965 by Edsger Dijkstra. It involves dealing with concurrent programming, synchronization issues, threads, deadlocks, and race conditions.
The Problem There are one or more philosophers sitting around a table, with a large bowl of spaghetti placed in the middle. In order for a philosopher to eat, they need to use both their left and right forks simultaneously."><meta property="og:type" content="article"><meta property="og:url" content="https://riceset.com/articles/philosophers/"><meta property="article:section" content="articles"><meta property="article:published_time" content="2023-08-15T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-15T00:00:00+00:00"></head><body><div class=container><header class=header><span class=header__inner><a href=https://riceset.com/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>riceset</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=https://github.com/riceset>GitHub</a></li><li><a href=/index.xml>RSS</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=https://github.com/riceset>GitHub</a></li><li><a href=/index.xml>RSS</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>An approach to solving the dining philosophers problem</h1><div class=post-meta><span class=post-date>2023-08-15</span>
<span class=post-author>‚Äî Written by Thiago Komeno</span></div><span class=post-tags><a href=https://riceset.com/tags/c/>#C</a>&nbsp;</span><div class=post-content><p><img src=https://github.com/riceset/riceset.com/assets/48802655/ce539555-067a-4bfe-8200-9929a7b12b82 alt=philo></p><h2 id=-overview>üëÄ Overview</h2><p>The <strong>Dining Philosophers Problem</strong> is a computer science problem formulated in 1965 by <a href=https://en.wikipedia.org/wiki/Edsger_W._Dijkstra>Edsger Dijkstra</a>. It involves dealing with concurrent programming, synchronization issues, threads, deadlocks, and race conditions.</p><h4 id=the-problem>The Problem</h4><p>There are one or more philosophers sitting around a table, with a large bowl of spaghetti placed in the middle. In order for a philosopher to eat, they need to use both their left and right forks simultaneously. There are as many forks as there are philosophers. Additionally, the philosophers cannot communicate with each other.</p><h4 id=the-routine>The routine</h4><p>Each philosopher successively eats, sleeps and thinks.</p><p><em>‚ÄúWhen a philosopher has finished eating, they start sleeping. Once awake they think again.‚Äù</em></p><h4 id=arguments-to-the-program-argv>Arguments to the program (argv)</h4><ul><li><code>number_of_philosophers</code></li><li><code>time_to_die</code></li><li><code>time_to_eat</code></li><li><code>time_to_sleep</code></li><li><code>number_of_times_each_philo_must_eat</code></li></ul><h4 id=expected-output>Expected output</h4><pre tabindex=0><code class=language-other data-lang=other>timestamp_in_ms X has taken a fork
timestamp_in_ms X is eating
timestamp_in_ms X is sleeping
timestamp_in_ms X is thinking
timestamp_in_ms X died
</code></pre><p>in which <code>X</code> is the philosopher ID.</p><p><em><strong>Note</strong></em>: The message announcing the death of a philosopher should be displayed in no more than <em><strong>10 ms</strong></em> after the actual death.</p><h2 id=-table>üé≤ Table</h2><p>In this project, we will be working with a main data structure in which will contain all the other ones, in the case of the philosophers project, as we will be dealing with threads, more specifically, one thread for each philosopher, we will have to find out how to put this table data structure inside each philosopher for accessing data from each thread.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> s_table
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>time_t</span> start_time;
</span></span><span style=display:flex><span>	t_args args;
</span></span><span style=display:flex><span>	t_philo <span style=color:#f92672>**</span>philos;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>pthread_mutex_t</span> <span style=color:#f92672>*</span>forks;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>In which, the <code>start_time</code> is initialized with the actual start time from the program (in miliseconds), <code>args</code> are the command line arguments (a.k.a argv, argument vector), <code>philos</code> is a double pointer but it might be easier to think about it as a pointer to an array of philosophers, and the <code>forks</code> &ldquo;array&rdquo;.</p><p>By the way, I decided creating a new data structure just to store the command line arguments in which I called <code>t_args</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> s_args
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> nb_philos;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>time_t</span> time_to_die;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>time_t</span> time_to_eat;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>time_t</span> time_to_sleep;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> must_eat;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>And that&rsquo;s how I initialized the values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_args</span>(t_args <span style=color:#f92672>*</span>args, <span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	args<span style=color:#f92672>-&gt;</span>nb_philos <span style=color:#f92672>=</span> <span style=color:#a6e22e>philo_atoi</span>(argv[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>	args<span style=color:#f92672>-&gt;</span>time_to_die <span style=color:#f92672>=</span> <span style=color:#a6e22e>philo_atoi</span>(argv[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>	args<span style=color:#f92672>-&gt;</span>time_to_eat <span style=color:#f92672>=</span> <span style=color:#a6e22e>philo_atoi</span>(argv[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>	args<span style=color:#f92672>-&gt;</span>time_to_sleep <span style=color:#f92672>=</span> <span style=color:#a6e22e>philo_atoi</span>(argv[<span style=color:#ae81ff>4</span>]);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>		args<span style=color:#f92672>-&gt;</span>must_eat <span style=color:#f92672>=</span> <span style=color:#a6e22e>philo_atoi</span>(argv[<span style=color:#ae81ff>5</span>]);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>		args<span style=color:#f92672>-&gt;</span>must_eat <span style=color:#f92672>=</span> MUST_EAT_NOT_SET;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em><strong>note</strong></em>: <code>MUST_EAT_NOT_SET</code> is a macro I defined to -1.</p><p>And if you&rsquo;re asking yourself why I didn&rsquo;t typedef any of these structures, that&rsquo;s because I &ldquo;typedefed&rdquo; all of them above their declaration in the header file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> s_table t_table;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> s_args t_args;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> s_philo t_philo;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> timeval t_timeval;
</span></span></code></pre></div><h2 id=-forks>üç¥ Forks</h2><p>In my table structure I&rsquo;ve got a mutex pointer called forks in which it will point to a block of memory containing all the mutexes used in the program.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>pthread_mutex_t</span> <span style=color:#f92672>*</span>forks;
</span></span></code></pre></div><p>Then, on my data structure that represents a philosopher I have an array with 2 values. The index 0 of this array represents the philosopher&rsquo;s left fork and the index 1 represents the right fork respectively.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> forks[<span style=color:#ae81ff>2</span>];
</span></span></code></pre></div><p><em><strong>note</strong></em>: The keyword <code>unsigned</code> is an alternative way of writing <code>unsigned int</code>.</p><p>As I declared my table as a regular variable into <code>main()</code>, I won&rsquo;t need to allocate memory for it.</p><p>We will just need to allocate memory for the mutexes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>alloc_forks</span>(t_table <span style=color:#f92672>*</span>table)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  table<span style=color:#f92672>-&gt;</span>forks <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>pthread_mutex_t</span>) <span style=color:#f92672>*</span> table<span style=color:#f92672>-&gt;</span>args.nb_philos);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>allocating the desired amount of bytes. (size of a mutex in bytes times the number of philosophers that is the number of forks, in other words, mutexes).</p><h4 id=initializing-the-mutexes>Initializing the mutexes</h4><p>after allocating memory to the created mutexes, we will have to initialize them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_forks</span>(t_table <span style=color:#f92672>*</span>table)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>alloc_forks</span>(table);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> table<span style=color:#f92672>-&gt;</span>args.nb_philos)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>pthread_mutex_init</span>(<span style=color:#f92672>&amp;</span>table<span style=color:#f92672>-&gt;</span>forks[i], NULL);
</span></span><span style=display:flex><span>		i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it for allocating and initializing mutexes :)</p><h2 id=-dealing-with-the-philosopher-data-structure>üí≠ Dealing with the philosopher data structure</h2><p>That&rsquo;s the definition for the philosopher data structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> s_philo
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>pthread_t</span> <span style=color:#66d9ef>thread</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> id;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> times_ate;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> forks[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>time_t</span> last_meal;
</span></span><span style=display:flex><span>	t_table <span style=color:#f92672>*</span>table;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Before doing anything else, we need to of course, allocate memory for the philosophers data structure.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>alloc_philos</span>(t_table <span style=color:#f92672>*</span>table)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	table<span style=color:#f92672>-&gt;</span>philos <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(t_philo <span style=color:#f92672>*</span>) <span style=color:#f92672>*</span> table<span style=color:#f92672>-&gt;</span>args.nb_philos);
</span></span><span style=display:flex><span>	i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> table<span style=color:#f92672>-&gt;</span>args.nb_philos)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		table<span style=color:#f92672>-&gt;</span>philos[i] <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(t_philo));
</span></span><span style=display:flex><span>		i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, we allocate the pointers that will point to each philosopher, then using these pointers that were allocated, we allocate the actual memory for each philosopher.</p><h4 id=initializing-the-philosophers>Initializing the philosophers</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_philos</span>(t_table <span style=color:#f92672>*</span>table)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>unsigned</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>alloc_philos</span>(table);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> table<span style=color:#f92672>-&gt;</span>args.nb_philos)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		table<span style=color:#f92672>-&gt;</span>philos[i]<span style=color:#f92672>-&gt;</span>id <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>		table<span style=color:#f92672>-&gt;</span>philos[i]<span style=color:#f92672>-&gt;</span>times_ate <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>		table<span style=color:#f92672>-&gt;</span>philos[i]<span style=color:#f92672>-&gt;</span>table <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>		table<span style=color:#f92672>-&gt;</span>philos[i]<span style=color:#f92672>-&gt;</span>forks[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>		table<span style=color:#f92672>-&gt;</span>philos[i]<span style=color:#f92672>-&gt;</span>forks[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> table<span style=color:#f92672>-&gt;</span>args.nb_philos;
</span></span><span style=display:flex><span>		i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now let&rsquo;s break down this function.</p><p>First, we need to assign an ID to each philosopher and it need to begin at 1. As we are indexing using <code>i</code> that usually gets initialized at 0, we need to add 1 to it to get the actual id.</p><p>So when <code>i</code> is 0, that means, the first philosopher will have the ID <code>i</code> + 1 that is 1.</p><p>The <code>times_ate</code> gets an initial value of 0 and we are assigning a pointer to <code>table</code> to have a reference inside each thread created later.</p><h4 id=assigning-forks>Assigning forks</h4><p>The current philosopher&rsquo;s left fork will be <code>i</code>. So for example, when $$i = 0$$ the philosopher&rsquo;s ID will be 1 so their left fork will be 0 and their right fork gotta be 1.</p><p>To get to the value of 1 we need to index it using the following formula:</p><p>$$
(i + 1) \mod n
$$</p><p>So imagine we have 2 philosophers (n = 2), the first philosopher&rsquo;s right fork will represent the following index:</p><p>$$
(0 + 1) \mod 2
$$</p><p>$$
= 1 \mod 2
$$</p><p>$$
= 1
$$</p><p>The second philosopher will have:</p><p>$$
(1 + 1) \mod 2
$$</p><p>$$
= 2 \mod 2
$$</p><p>$$
= 0
$$</p><p>So the first philosopher&rsquo;s left fork will be 0, and the right fork will be 1, while the second philosopher&rsquo;s left fork will be 1 and the right fork will be 0 again. We just succeeded in simulating a round table with forks in between each philosopher.</p><p><img src=https://res.craft.do/user/preview/a56c5213-5c17-64c0-d902-b9958ea11cb4/doc/9BCB3C86-9D37-4BE9-863E-5303AA81C84B/4DE81475-B9BB-4B1F-AC51-8AFD3C416B8A_1/4aMSLV7rtyUkDXHAUXORo5u5POCWDIyqsbGsLMoZV4kz/Drawing.jpg alt=Drawing></p><h2 id=-calculating-the-time-stamps>‚è≥ Calculating the time stamps</h2><p>As the program wants the output in miliseconds and the function <code>gettimeofday()</code> gives us values in seconds and microseconds, we have to convert both to miliseconds and sum them up.</p><h4 id=remembering-that>remembering that</h4><p>$$
1s = 1000ms
$$</p><h4 id=and-that>and that</h4><p>$$
1Œºs = \frac{1}{1000}ms
$$</p><p>$$
\therefore 1Œºs = 0.001ms
$$</p><p>Now with all the values in miliseconds, we can sum them up to get the current time in miliseconds.</p><h4 id=example>Example:</h4><p>Let‚Äôs try converting the following value that is given in seconds to miliseconds.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>time_t</span> <span style=color:#a6e22e>s_to_ms</span>(<span style=color:#66d9ef>time_t</span> s)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (s <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>$$
41923s \times 1000 = 41923000ms
$$</p><p>Now, let‚Äôs convert the microsecond part to miliseconds (discarding the decimal part).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>time_t</span> <span style=color:#a6e22e>us_to_ms</span>(<span style=color:#66d9ef>time_t</span> us)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (us <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>$$
\frac{126500}{1000}Œºs = 126ms
$$</p><p>Summing the seconds and microseconds now converted to miliseconds we get:</p><p>$$
41923000ms + 126ms = 41923126ms
$$</p><p>Now, to get the current time you just subtract the <code>gettimeofday()</code> call from the start time that would be the value you saved when calling it for the first time. That would be the code for the conversion made:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>get_current_time</span>(<span style=color:#66d9ef>time_t</span> <span style=color:#f92672>*</span>s, <span style=color:#66d9ef>time_t</span> <span style=color:#f92672>*</span>us)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	t_timeval tv;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gettimeofday</span>(<span style=color:#f92672>&amp;</span>tv, NULL);
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>s <span style=color:#f92672>=</span> tv.tv_sec;
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>us <span style=color:#f92672>=</span> tv.tv_usec;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>time_t</span> s;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>time_t</span> us;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>get_current_time</span>(<span style=color:#f92672>&amp;</span>s, <span style=color:#f92672>&amp;</span>us);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;current_time_in_ms:%ld&#34;</span>, <span style=color:#a6e22e>s_to_ms</span>(s) <span style=color:#f92672>+</span> <span style=color:#a6e22e>us_to_ms</span>(us));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=-references>üöÄ References</h2><h4 id=my-repository>My repository</h4><p><a href=https://github.com/riceset/philosophers>GitHub - riceset/philosophers</a></p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Suggested</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://riceset.com/articles/understanding-the-stack-data-structure/><span class=button__text>Understanding the stack data structure</span>
<span class=button__icon>‚Üí</span></a></span></div></div></div></div><footer class=footer><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class=footer__inner><div class="copyright copyright--user">¬© 2023 riceset</div></div></footer><script src=https://riceset.com/assets/main.js></script>
<script src=https://riceset.com/assets/prism.js></script></div></body></html>