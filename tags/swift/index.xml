<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Swift on riceset</title><link>https://riceset.com/tags/swift/</link><description>Recent content in Swift on riceset</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2023 riceset</copyright><lastBuildDate>Tue, 19 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://riceset.com/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding MVVM in SwiftUI (Stanford CS193p)</title><link>https://riceset.com/articles/understanding-mvvm-in-swiftui-stanford-cs193p/</link><pubDate>Tue, 19 Dec 2023 00:00:00 +0000</pubDate><guid>https://riceset.com/articles/understanding-mvvm-in-swiftui-stanford-cs193p/</guid><description>
&lt;img src="https://riceset.com/images/mvvm.png"/>
&lt;p>MVVM is a design paradigm that stands for &lt;em>Model-View-ViewModel&lt;/em>.&lt;/p>
&lt;h3 id="model">Model&lt;/h3>
&lt;ul>
&lt;li>It is completely UI independent (simple swift files)&lt;/li>
&lt;li>Contains the &lt;strong>data&lt;/strong> + &lt;strong>logic&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="view">View&lt;/h3>
&lt;ul>
&lt;li>A reflection of the current state of the model&lt;/li>
&lt;li>Declarative (the view is determined by what &lt;code>body&lt;/code> returns)&lt;/li>
&lt;/ul>
&lt;h3 id="viewmodel">ViewModel&lt;/h3>
&lt;ul>
&lt;li>Binds the View to the Model so that changes in the model cause the view to get rebuilt&lt;/li>
&lt;li>Example: gets data from a SQL database and puts it into an array&lt;/li>
&lt;li>It constantly looks for changes in the model and publishes &amp;rsquo;to everyone&amp;rsquo; that something has changed&lt;/li>
&lt;li>Can modify the model&lt;/li>
&lt;/ul>
&lt;h2 id="applying-mvvm-in-memorize">Applying MVVM in Memorize&lt;/h2>
&lt;h3 id="model-1">Model&lt;/h3>
&lt;p>Now let&amp;rsquo;s return to coding Memorize. We are going to define our model for this memory game as the following struct:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MemoryGame&lt;/span>&amp;lt;CardContent&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> cards: Array&amp;lt;Card&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Card&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isFaceUp: Bool = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isMatched: Bool = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> content: CardContent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we are declaring an array of cards and defining the &lt;code>Card&lt;/code> type below as a struct. The content of the &lt;code>Card&lt;/code> is going to be a generic and we have to specify what variable type we want it to be when using the &lt;code>MemoryGame&lt;/code> struct (just like when using an array e.g. &lt;code>Array&amp;lt;Int&amp;gt;&lt;/code>)&lt;/p>
&lt;p>We are also setting a default value for &lt;code>isFaceUp&lt;/code> and &lt;code>isMatched&lt;/code> for the &lt;code>Card&lt;/code> struct so we don&amp;rsquo;t have to set it every time.&lt;/p>
&lt;p>Now we can create an initializer for this model. It gets the number of pairs of cards
as a parameter and creates cards for us.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">init&lt;/span>(numberOfPairsOfCards: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cards = Array&amp;lt;Card&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Observation: When we create our own initializer we are going to have to initialize all variables being used inside the struct by ourselves.&lt;/p>
&lt;p>Now let&amp;rsquo;s create a &lt;code>for&lt;/code> loop to add cards to our array:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> pairIndex &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;numberOfPairsOfCards {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cards.append(content: ???)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>here we are using pairIndex (something like &lt;code>i&lt;/code> in C) and looping numberOfPairsOfCards times where on each iteration we are appending a newly created card to our &lt;code>cards&lt;/code> array.&lt;/p>
&lt;p>The problem here is that we don&amp;rsquo;t have our content yet. To solve this let&amp;rsquo;s create a function called &lt;code>createCardContent()&lt;/code> that receives &lt;code>pairIndex&lt;/code> and returns &lt;code>CardContent&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> pairIndex &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;numberOfPairsOfCards {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cards.append(content: createCardContent(pairIndex))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Passing this function as a parameter in the initializer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">init&lt;/span>(numberOfPairsOfCards: Int, createCardContent: (Int) -&amp;gt; CardContent)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="viewmodel-1">ViewModel&lt;/h3>
&lt;p>The ViewModel is defined as a class:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">EmojiMemoryGame&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createCardContent: { (index: Int) -&amp;gt; String &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ðŸ‘»&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>here we can use our model defining it as a private variable (making it only accessible from this class). Then we assign it to a &lt;code>MemoryGame&lt;/code> instance and set &lt;code>CardContent&lt;/code> type to a string. Then initialize it with 4 pairs of cards and pass a function to create the contents of the cards.&lt;/p>
&lt;p>As Swift already knows the types for the input and output for this function because it was specified in the model we can simplify this function removing the types for the input and output and even remove the &lt;code>return&lt;/code> statement and parenthesis:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createCardContent: { index &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ðŸ‘»&amp;#34;&lt;/span> })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As &lt;code>createCardContent&lt;/code> is the last parameter we can simplify it like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> index &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ðŸ‘»&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Since we are not using the &lt;code>index&lt;/code> variable we can omit it too:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ðŸ‘»&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="using-static">Using static&lt;/h4>
&lt;p>Let&amp;rsquo;s try to insert the emojis array into our ViewModel:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> emojis: [String] = [&lt;span style="color:#e6db74">&amp;#34;ðŸš—&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ðŸš•&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ðŸš™&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ðŸšŒ&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now let&amp;rsquo;s assign an emoji indexed from this array to the contents of our card:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pairIndex &lt;span style="color:#66d9ef">in&lt;/span> emojis[pairIndex]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But we cannot initialize a property (e.g. let, var) with a value that depends on another property because the order of initialization of properties is random.&lt;/p>
&lt;p>To solve this we can use an initializer to explicitly set the order of initialization of our properties, make the &lt;code>emojis&lt;/code> constant global or as a better option we can make it &lt;code>static&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> emojis: [String] = [&lt;span style="color:#e6db74">&amp;#34;ðŸš—&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ðŸš•&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ðŸš™&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;ðŸšŒ&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using type variables (e.g. &lt;code>static var&lt;/code>, &lt;code>static let&lt;/code>) and type functions (&lt;code>static func&lt;/code>) makes them &amp;lsquo;global&amp;rsquo; to all instances of this class. So in contrast to a normal variable that would get created on each instance, a type variable or type function will be created only once and referenced from other instances.&lt;/p></description></item><item><title>My Swift Guide: Personal Reference for Swift Programming Concepts</title><link>https://riceset.com/articles/my-swift-guide-personal-reference-for-swift-programming-concepts/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://riceset.com/articles/my-swift-guide-personal-reference-for-swift-programming-concepts/</guid><description>
&lt;img src="https://riceset.com/images/swift-guide.png"/>
&lt;h3 id="functions">Functions&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(operand: Int, by: Int) -&amp;gt; Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> operand &lt;span style="color:#f92672">*&lt;/span> by
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>multiply(operand: &lt;span style="color:#ae81ff">5&lt;/span>, by: &lt;span style="color:#ae81ff">6&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="using-external-and-internal-labels-to-improve-readability">Using external and internal labels to improve readability&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(&lt;span style="color:#66d9ef">_&lt;/span> operand1: Int, by operand2: Int) -&amp;gt; Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> operand1 &lt;span style="color:#f92672">*&lt;/span> operand2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>multiply(&lt;span style="color:#ae81ff">5&lt;/span>, by: &lt;span style="color:#ae81ff">6&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="functions-with-function-parameters">Functions with function parameters&lt;/h4>
&lt;p>You can make a function receive another function as a parameter (similar to function pointers in C)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(what: () -&amp;gt; Bool) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="functions-as-types">Functions as types&lt;/h4>
&lt;p>We can declare variables of type &amp;lsquo;function&amp;rsquo; in Swift:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> foo: (Double) -&amp;gt; Double
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="structs-and-classes">Structs and Classes&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>struct&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Passed by&lt;/td>
&lt;td>value&lt;/td>
&lt;td>reference&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>gets copied&lt;/td>
&lt;td>passed via pointers&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Optimization&lt;/td>
&lt;td>copy on write&lt;/td>
&lt;td>automatically reference counting&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>only gets copied when you modify it&lt;/td>
&lt;td>Swift keeps track of how many pointers are pointing to a piece of memory on the heap and when it goes to 0 it frees this memory&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Paradigm&lt;/td>
&lt;td>functional&lt;/td>
&lt;td>object-oriented&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Inheritance&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Initialization&lt;/td>
&lt;td>free init for (all variables)&lt;/td>
&lt;td>free init (does not initialize variables)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Mutability&lt;/td>
&lt;td>Explicitly stated (var and let)&lt;/td>
&lt;td>Always mutable&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="generics">Generics&lt;/h3>
&lt;p>These are data structures that we do not care about the type their values are (e.g. an array)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Array&lt;/span>&amp;lt;Element&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">_&lt;/span> element: Element) { ... }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In which &lt;code>Element&lt;/code> is a generic type.&lt;/p>
&lt;h4 id="use">Use&lt;/h4>
&lt;p>We define the array type on the declaration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = Array&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>