<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Swift on riceset</title><link>https://riceset.com/tags/swift/</link><description>Recent content in Swift on riceset</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© 2023 riceset</copyright><lastBuildDate>Tue, 19 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://riceset.com/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding MVVM in SwiftUI (Stanford CS193p)</title><link>https://riceset.com/articles/mvvm/</link><pubDate>Tue, 19 Dec 2023 00:00:00 +0000</pubDate><guid>https://riceset.com/articles/mvvm/</guid><description>
&lt;img src="https://riceset.com/images/mvvm.png"/>
&lt;p>MVVM is a design paradigm that stands for &lt;em>Model-View-ViewModel&lt;/em>.&lt;/p>
&lt;h3 id="model">Model&lt;/h3>
&lt;ul>
&lt;li>It is completely UI independent (simple swift files)&lt;/li>
&lt;li>Contains the &lt;strong>data&lt;/strong> + &lt;strong>logic&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="view">View&lt;/h3>
&lt;ul>
&lt;li>A reflection of the current state of the model&lt;/li>
&lt;li>Declarative (the view is determined by what &lt;code>body&lt;/code> returns)&lt;/li>
&lt;/ul>
&lt;h3 id="viewmodel">ViewModel&lt;/h3>
&lt;ul>
&lt;li>Binds the View to the Model so that changes in the model cause the view to get rebuilt&lt;/li>
&lt;li>Example: gets data from a SQL database and puts it into an array&lt;/li>
&lt;li>It constantly looks for changes in the model and publishes &amp;rsquo;to everyone&amp;rsquo; that something has changed&lt;/li>
&lt;li>Can modify the model&lt;/li>
&lt;/ul>
&lt;h2 id="applying-mvvm-in-memorize">Applying MVVM in Memorize&lt;/h2>
&lt;h3 id="model-1">Model&lt;/h3>
&lt;p>Now let&amp;rsquo;s return to coding Memorize. We are going to define our model for this memory game as the following struct:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MemoryGame&lt;/span>&amp;lt;CardContent&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> cards: Array&amp;lt;Card&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Card&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isFaceUp: Bool = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isMatched: Bool = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> content: CardContent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we are declaring an array of cards and defining the &lt;code>Card&lt;/code> type below as a struct. The content of the &lt;code>Card&lt;/code> is going to be a generic and we have to specify what variable type we want it to be when using the &lt;code>MemoryGame&lt;/code> struct (just like when using an array e.g. &lt;code>Array&amp;lt;Int&amp;gt;&lt;/code>)&lt;/p>
&lt;p>We are also setting a default value for &lt;code>isFaceUp&lt;/code> and &lt;code>isMatched&lt;/code> for the &lt;code>Card&lt;/code> struct so we don&amp;rsquo;t have to set it every time.&lt;/p>
&lt;p>Now we can create an initializer for this model. It gets the number of pairs of cards
as a parameter and creates cards for us.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">init&lt;/span>(numberOfPairsOfCards: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cards = Array&amp;lt;Card&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Observation: When we create our own initializer we are going to have to initialize all variables being used inside the struct by ourselves.&lt;/p>
&lt;p>Now let&amp;rsquo;s create a &lt;code>for&lt;/code> loop to add cards to our array:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> pairIndex &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;numberOfPairsOfCards {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cards.append(content: ???)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>here we are using pairIndex (something like &lt;code>i&lt;/code> in C) and looping numberOfPairsOfCards times where on each iteration we are appending a newly created card to our &lt;code>cards&lt;/code> array.&lt;/p>
&lt;p>The problem here is that we don&amp;rsquo;t have our content yet. To solve this let&amp;rsquo;s create a function called &lt;code>createCardContent()&lt;/code> that receives &lt;code>pairIndex&lt;/code> and returns &lt;code>CardContent&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> pairIndex &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;numberOfPairsOfCards {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cards.append(content: createCardContent(pairIndex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Passing this function as a parameter in the initializer:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">init&lt;/span>(numberOfPairsOfCards: Int, createCardContent: (Int) -&amp;gt; CardContent)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="viewmodel-1">ViewModel&lt;/h3>
&lt;p>The ViewModel is defined as a class:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">EmojiMemoryGame&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>, createCardContent: { (index: Int) -&amp;gt; String &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>here we can use our model defining it as a private variable (making it only accessible from this class). Then we assign it to a &lt;code>MemoryGame&lt;/code> instance and setting &lt;code>CardContent&lt;/code> type to a string. Then initializing it with 4 pairs of cards and passing a function to create the contents of the cards.&lt;/p>
&lt;p>As Swift already knows the types for the input and output for this function because it was specified in the model we can simplify this function removing the types for the input and output and even remove the &lt;code>return&lt;/code> statement and parenthesis:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>, createCardContent: { index &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span> })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As &lt;code>createCardContent&lt;/code> is the last parameter we can simplify it like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> index &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Since we are not using the &lt;code>index&lt;/code> variable we can omit it too:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> model = MemoryGame&amp;lt;String&amp;gt;(numberOfPairsOfCards: &lt;span style="color:#ae81ff">4&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">_&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Getting started with SwiftUI (Stanford CS193p)</title><link>https://riceset.com/articles/getting-started-with-swiftui-stanford-cs193p/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://riceset.com/articles/getting-started-with-swiftui-stanford-cs193p/</guid><description>
&lt;img src="https://riceset.com/images/swiftui-intro-cover.png"/>
&lt;p>This struct behaves like a view (the struct conforms to the &lt;code>View&lt;/code> protocol)
The &lt;code>View&lt;/code> protocol requires you to have the body variable (of type &amp;lsquo;some View&amp;rsquo;)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The block (curly brackets) after the variable declaration represents a function (closure) and the value it returns gets assigned to the variable &lt;code>body&lt;/code>. As long as it is a view (&lt;code>VStack&lt;/code>, &lt;code>Text&lt;/code>, &lt;code>Image&lt;/code>, etc) it is ok to assign it. (note: writing the keyword &lt;code>return&lt;/code> here is optional!)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Text(&lt;span style="color:#e6db74">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="shapes">Shapes&lt;/h3>
&lt;h4 id="roundedrectangle">RoundedRectangle()&lt;/h4>
&lt;p>We can return the &lt;code>RoundedRectangle()&lt;/code> view specifying its &lt;code>cornerRadius&lt;/code> and calling modifier functions like &lt;code>.padding()&lt;/code> (can receive an optional argument like &lt;code>.horizontal&lt;/code>) and &lt;code>.stroke()&lt;/code> (contrary to &lt;code>.fill()&lt;/code>) to outline a shape (can receive an optional argument like &lt;code>lineWidth: 3&lt;/code>).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RoundedRectangle(cornerRadius: &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stroke()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .padding()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RoundedRectangle(cornerRadius: &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stroke(lineWidth: &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .padding(.horizontal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .foregroundColor(.red)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tip: You can write just &lt;code>.red&lt;/code> instead of &lt;code>Color.red&lt;/code> when defining the foreground color.&lt;/p>
&lt;h3 id="view-combiners">View Combiners&lt;/h3>
&lt;h4 id="the-zstack">The ZStack()&lt;/h4>
&lt;p>The &lt;code>ZStack()&lt;/code> receives a closure as a parameter. (this closure is called a &lt;strong>View Builder&lt;/strong>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZStack(content: {})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;strong>View Builder&lt;/strong> allows us to list all the views we want to combine and turns it into another view. You also don&amp;rsquo;t need to write &lt;code>return&lt;/code> inside the &lt;strong>View Builder&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        ZStack(content: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            RoundedRectangle(cornerRadius: &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                .stroke()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                .padding()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            Text(&lt;span style="color:#e6db74">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="modifying-the-view-combiner">Modifying the View Combiner&lt;/h4>
&lt;p>Applying a modifier function to a view combiner will apply the properties to all the view within it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        ZStack(content: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            RoundedRectangle(cornerRadius: &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                .stroke()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            Text(&lt;span style="color:#e6db74">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        .padding()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        .foregroundColor(.red)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Preview:&lt;/p>
&lt;p>&lt;img src="https://github.com/riceset/riceset.com/assets/48802655/0b64ae6f-4c52-4f91-ab17-230027e9daa0" alt="middle">&lt;/p>
&lt;h4 id="setting-the-alignment">Setting the alignment&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        ZStack(alignment: .top, content: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            RoundedRectangle(cornerRadius: &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>                .stroke()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>            Text(&lt;span style="color:#e6db74">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        .padding()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        .foregroundColor(.red)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Preview:&lt;/p>
&lt;p>&lt;img src="https://github.com/riceset/riceset.com/assets/48802655/714a35d1-26e1-4092-8ca8-29213d99c471" alt="top">&lt;/p>
&lt;h4 id="simplifying-the-code">Simplifying the code&lt;/h4>
&lt;p>When the last argument of a function is also a function you can simplify the code like this:&lt;/p>
&lt;p>This code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        ZStack(content: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>becomes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        ZStack() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can also remove the parenthesis from the ZStack&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>    &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        ZStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>        }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>    }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="encapsulating-views">Encapsulating views&lt;/h4>
&lt;p>To avoid redundancy, we can get our &lt;code>ZStack&lt;/code> representing a card and turn it into a view itself.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">CardView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RoundedRectangle(cornerRadius: &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stroke()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then call it form the &lt;code>ContentView&lt;/code> in a &lt;code>HStack&lt;/code> (horizontal stack):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .padding()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .foregroundColor(.red)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://github.com/riceset/riceset.com/assets/48802655/b10032d3-1385-4395-aa7b-af2e09d08c26" alt="cardviewhstacked">&lt;/p>
&lt;h4 id="creating-local-variables">Creating local variables&lt;/h4>
&lt;p>Instead of repetitively calling &lt;code>RoundedRectangle()&lt;/code>, we can assign it to a variable (&lt;code>rectangle&lt;/code> in this case) and use it instead to make our code look cleaner.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> rectangle = RoundedRectangle(cornerRadius: &lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rectangle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .fill()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .foregroundColor(.white)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rectangle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stroke(lineWidth: &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Text(&lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="flipping-the-card-using-boolean-values">Flipping the card using boolean values&lt;/h4>
&lt;p>Here, we created a boolean variable called &lt;code>isFaceUp&lt;/code> and initialized it to &lt;code>true&lt;/code>. Then, using the &lt;code>if&lt;/code> control flow structure, we can change what kind of view we would like to display (if it is the card with a white background and text or just a card filled in red.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> isFaceUp = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> isFaceUp {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rectangle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .fill()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .foregroundColor(.white)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rectangle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .stroke(lineWidth: &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .font(.largeTitle)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rectangle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .fill()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Passing &lt;code>isFaceUp&lt;/code> as a parameter when calling &lt;code>CardView&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>HStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(isFaceUp: &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(isFaceUp: &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(isFaceUp: &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(isFaceUp: &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://github.com/riceset/riceset.com/assets/48802655/7a3d9c14-63ca-4e0e-8090-0a0d9b34f623" alt="flippedcards">&lt;/p>
&lt;h4 id="view-mutability-and-state">View Mutability and @State&lt;/h4>
&lt;p>If we try to add &lt;code>.onTapGesture()&lt;/code> to our &lt;code>ZStack&lt;/code> to change the value of a variable, we will get an error because all views are immutable. In this case, we want to change the value of &lt;code>isFaceUp&lt;/code>, but as it is not possible we can add &lt;code>@State&lt;/code> to it to turn it into a pointer to a boolean to somewhere in memory and whenever it changes the &lt;code>body&lt;/code> view gets rebuilt.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>@State &lt;span style="color:#66d9ef">var&lt;/span> isFaceUp = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onTapGesture {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isFaceUp = &lt;span style="color:#f92672">!&lt;/span>isFaceUp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="using-dynamic-text">Using dynamic text&lt;/h4>
&lt;p>We can create a new variable inside our &lt;code>CardView&lt;/code> called content (representing the content for the &lt;code>Text&lt;/code>) and pass the content dynamically from the &lt;code>ContentView&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">CardView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> content: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(content)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then from the &lt;code>ContentView&lt;/code>, let&amp;rsquo;s create an array of strings for the card contents and indexing from this array when passing the content to the &lt;code>CardView&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> emojis: [String] = [&lt;span style="color:#e6db74">&amp;#34;👻&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;⛩️&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🔗&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🌹&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emojis[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emojis[&lt;span style="color:#ae81ff">1&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emojis[&lt;span style="color:#ae81ff">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emojis[&lt;span style="color:#ae81ff">3&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But, to write it in a less methodical way we can use a &lt;code>ForEach&lt;/code> statement with &lt;code>emoji&lt;/code> being a variable representing the current item from an iteration.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>ForEach(emojis) { emoji &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emoji)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>But the code above will not work because to use a &lt;code>ForEach&lt;/code> we need to make each item from our array conform to the &lt;code>Identifiable&lt;/code> protocol meaning that each item must be unique and have an ID.&lt;/p>
&lt;p>To solve this problem, we can add &lt;code>id&lt;/code> as a parameter to &lt;code>ForEach&lt;/code> and set it to &lt;code>\.self&lt;/code> meaning that the variable itself is going to be it&amp;rsquo;s own ID.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>ForEach(emojis, id: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.&lt;span style="color:#66d9ef">self&lt;/span>) { emoji &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emoji)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="working-with-ranges">Working with ranges&lt;/h4>
&lt;p>Imagine we have a really long array and only want to display emojis from a certain range. We can achieve this by using the indexing syntax.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> emojis: [String] = [&lt;span style="color:#e6db74">&amp;#34;🚗&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚕&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚙&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚌&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚎&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🏎️&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚓&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚑&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚒&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚐&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚚&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚛&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚜&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚲&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🛴&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🛵&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🏍️&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🛺&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚔&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚍&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚘&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚖&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚡&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚠&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚟&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚃&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚞&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚝&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚄&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;🚅&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;&lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#75715e">//Will exclude the 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0.&lt;/span>..&lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#75715e">//Will include the 5&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, let&amp;rsquo;s index &lt;code>emojis&lt;/code> inside out &lt;code>ForEach&lt;/code> to only the first 4 items:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>ForEach(emojis[&lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;&lt;span style="color:#ae81ff">4&lt;/span>], id: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.&lt;span style="color:#66d9ef">self&lt;/span>) { emoji &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emoji)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="buttons">Buttons&lt;/h4>
&lt;p>Now we are going to add a button to add and remove cards. This is how we use a &lt;code>Button&lt;/code> in Swift:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>Button(action: {}, label: {})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can now create a variable to keep track of how many items we want to display and set it as the range when iterating through the &lt;code>emojis&lt;/code> array:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>@State &lt;span style="color:#66d9ef">var&lt;/span> emojiCount = &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ForEach(emojis[&lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;emojiCount], id: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.&lt;span style="color:#66d9ef">self&lt;/span>) { emoji &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emoji)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we can create 2 buttons and increment/decrement this variable (Inserting it into a horizontal stack and adding a &lt;code>Spacer()&lt;/code> in between the 2 buttons.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>HStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Button(action: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emojiCount &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;+&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Spacer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Button(action: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emojiCount &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.padding()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, to clean up the code we can turn the block of code for creating the &lt;code>Button&lt;/code> into a new variable of type &lt;code>some View&lt;/code> and use it instead.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> add: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Button(action: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emojiCount &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;+&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> remove: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Button(action: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emojiCount &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(&lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And use it like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>HStack {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Spacer()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remove
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="using-sfsymbols-for-the-buttons">Using SFSymbols for the buttons&lt;/h5>
&lt;p>Syntax:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>Image(systemName: &lt;span style="color:#e6db74">&amp;#34;SYMBOLNAME&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Use case:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>Button(action: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emojiCount &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(systemName: &lt;span style="color:#e6db74">&amp;#34;minus.circle&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="syntactic-sugar-for-simplifying-the-button-syntax">Syntactic sugar for simplifying the Button syntax&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>Button(action: {}, label: {})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Becomes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>Button {} label: {}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="adding-limits-for-our-ranges">Adding limits for our ranges&lt;/h5>
&lt;p>When incrementing/decrementing &lt;code>emojiCount&lt;/code>, we have to be careful to not let it get to an invalid index inside our array (a value less than zero or upper to the array&amp;rsquo;s number of elements.)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> add: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Button {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (emojiCount &lt;span style="color:#f92672">&amp;lt;&lt;/span> emojis.count) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emojiCount &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> remove: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Button {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (emojiCount &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emojiCount &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="grids">Grids&lt;/h4>
&lt;p>We can use a &lt;code>LazyVGrid&lt;/code> Instead of the &lt;code>HStack&lt;/code> to order our cards into a grid. (When using a &lt;code>LazyVGrid&lt;/code> we only have to specify the number of columns and all the rows are going to be created as necessary contrary to a &lt;code>LazyHGrid&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>LazyVGrid(columns: [GridItem(), GridItem(), GridItem()]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(emojis[&lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;emojiCount], id: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.&lt;span style="color:#66d9ef">self&lt;/span>) { emoji &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emoji)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>where columns is an array of &lt;code>GridItem()&lt;/code>&lt;/p>
&lt;h4 id="setting-the-aspect-ratio-for-a-card">Setting the aspect ratio for a card&lt;/h4>
&lt;p>We can call &lt;code>.aspectRatio()&lt;/code> on our &lt;code>CardView&lt;/code> to set the aspect ratio like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>CardView(content: emoji).aspectRatio(&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, contentMode: .fit)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Sets the aspect ratio to 2 wide / 3 high.&lt;/p>
&lt;h4 id="using-a-scroll-view">Using a scroll view&lt;/h4>
&lt;p>We can wrap our &lt;code>LazyVGrid&lt;/code> into a &lt;code>ScrollView&lt;/code> to be able to scroll:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>ScrollView {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LazyVGrid(columns: [GridItem(), GridItem(), GridItem()]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(emojis[&lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;emojiCount], id: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.&lt;span style="color:#66d9ef">self&lt;/span>) { emoji &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emoji).aspectRatio(&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, contentMode: .fit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="working-with-an-adaptive-grid-item">Working with an adaptive grid item&lt;/h4>
&lt;p>We can set our array of grid items to just one &lt;code>GridItem()&lt;/code> and make it adaptive setting the minimum width for the row.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>GridItem(.adaptive(minimum: &lt;span style="color:#ae81ff">80&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>ScrollView {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LazyVGrid(columns: [GridItem(.adaptive(minimum: &lt;span style="color:#ae81ff">80&lt;/span>))]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(emojis[&lt;span style="color:#ae81ff">0.&lt;/span>.&amp;lt;emojiCount], id: &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.&lt;span style="color:#66d9ef">self&lt;/span>) { emoji &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CardView(content: emoji).aspectRatio(&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, contentMode: .fit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://github.com/riceset/riceset.com/assets/48802655/28d56dc8-2843-44c1-9c55-286b7e2b397e" alt="adaptive">&lt;/p></description></item><item><title>My Swift Guide: Personal Reference for Swift Programming Concepts</title><link>https://riceset.com/articles/my-swift-guide-personal-reference-for-swift-programming-concepts/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://riceset.com/articles/my-swift-guide-personal-reference-for-swift-programming-concepts/</guid><description>
&lt;img src="https://riceset.com/images/swift-guide.png"/>
&lt;h3 id="functions">Functions&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(operand: Int, by: Int) -&amp;gt; Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> operand &lt;span style="color:#f92672">*&lt;/span> by
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>multiply(operand: &lt;span style="color:#ae81ff">5&lt;/span>, by: &lt;span style="color:#ae81ff">6&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="using-external-and-internal-labels-to-improve-readability">Using external and internal labels to improve readability&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(&lt;span style="color:#66d9ef">_&lt;/span> operand1: Int, by operand2: Int) -&amp;gt; Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> operand1 &lt;span style="color:#f92672">*&lt;/span> operand2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>multiply(&lt;span style="color:#ae81ff">5&lt;/span>, by: &lt;span style="color:#ae81ff">6&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="functions-with-function-parameters">Functions with function parameters&lt;/h4>
&lt;p>You can make a function receive another function as a parameter (similar to function pointers in C)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(what: () -&amp;gt; Bool) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="functions-as-types">Functions as types&lt;/h4>
&lt;p>We can declare variables of type &amp;lsquo;function&amp;rsquo; in Swift:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> foo: (Double) -&amp;gt; Double
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="structs-and-classes">Structs and Classes&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>struct&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Passed by&lt;/td>
&lt;td>value&lt;/td>
&lt;td>reference&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>gets copied&lt;/td>
&lt;td>passed via pointers&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Optimization&lt;/td>
&lt;td>copy on write&lt;/td>
&lt;td>automatically reference counting&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>only gets copied when you modify it&lt;/td>
&lt;td>Swift keeps track of how many pointers are pointing to a piece of memory on the heap and when it goes to 0 it frees this memory&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Paradigm&lt;/td>
&lt;td>functional&lt;/td>
&lt;td>object-oriented&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Inheritance&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Initialization&lt;/td>
&lt;td>free init for (all variables)&lt;/td>
&lt;td>free init (does not initialize variables)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Mutability&lt;/td>
&lt;td>Explicitly stated (var and let)&lt;/td>
&lt;td>Always mutable&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="generics">Generics&lt;/h3>
&lt;p>These are data structures that we do not care about the type their values are (e.g. an array)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Array&lt;/span>&amp;lt;Element&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">_&lt;/span> element: Element) { ... }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In which &lt;code>Element&lt;/code> is a generic type.&lt;/p>
&lt;h4 id="use">Use&lt;/h4>
&lt;p>We define the array type on the declaration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = Array&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>